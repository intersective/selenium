/**
 * should not use the keyboard actions when the test requires to run on the server
 * it would cause issues when the server can not trigger the keyboard signals
 */
package service;


import java.awt.AWTException;
import java.awt.Robot;

import org.openqa.selenium.WebElement;
import org.testng.Assert;

import common.BuildConfig;
import common.ElementType;


public class UIAction {

	public static void pasteAndEnter() throws AWTException {
		Robot robot = new Robot();
		robot.keyPress(java.awt.event.KeyEvent.VK_ENTER);
	    robot.keyRelease(java.awt.event.KeyEvent.VK_ENTER);
	    robot.keyPress(java.awt.event.KeyEvent.VK_CONTROL);
	    robot.keyPress(java.awt.event.KeyEvent.VK_V);
	    robot.keyRelease(java.awt.event.KeyEvent.VK_CONTROL);
	    robot.keyRelease(java.awt.event.KeyEvent.VK_V);
	    robot.keyPress(java.awt.event.KeyEvent.VK_ENTER);
	    robot.keyRelease(java.awt.event.KeyEvent.VK_ENTER);
	}
	
	public static void openNewTab() throws AWTException {
		Robot r = new Robot();                          
		r.keyPress(java.awt.event.KeyEvent.VK_CONTROL); 
		r.keyPress(java.awt.event.KeyEvent.VK_T); 
		r.keyRelease(java.awt.event.KeyEvent.VK_CONTROL); 
		r.keyRelease(java.awt.event.KeyEvent.VK_T);
	}
	
	public static void hitEnter() throws AWTException {
		Robot robot = new Robot();
		robot.keyPress(java.awt.event.KeyEvent.VK_ENTER);
	    robot.keyRelease(java.awt.event.KeyEvent.VK_ENTER);
	}
	
	/**
	 * wait for an element becoming visible
	 * @param sw
	 * @param locator
	 * @param type
	 * @param timeoutInSeconds
	 * @return WebElement
	 */
	public static WebElement waitForElementVisible(SeleniumWaiter sw, String locator, ElementType type, int waitTime) {
		WebElement webElement;
		
		if (BuildConfig.headless) {
			Tools.forceToWait(8);
			webElement = sw.waitForElement(locator, type, waitTime);
		} else {
			webElement = sw.waitForElement(locator, type, waitTime);
			while (webElement != null && !webElement.isDisplayed()) {
				Tools.forceToWaitInMilli(100);
				webElement = sw.waitForElement(locator, type, waitTime);
			}
		}
		
		return webElement;
	}
	
	public static WebElement waitForElementVisible(SeleniumWaiter sw, String locator) {
		return waitForElementVisible(sw, locator, BuildConfig.elementWaitTime);
	}
	
	public static WebElement waitForElementVisible(SeleniumWaiter sw, String locator, int waitTime) {
		return waitForElementVisible(sw, locator, ElementType.CSSSELECTOR, waitTime);
	}
	
	public static WebElement waitForElementVisibleWithAssert(SeleniumWaiter sw, String locator) {
		return waitForElementVisibleWithAssert(sw, locator, BuildConfig.elementWaitTime);
	}
	
	/**
	 * it continuously retrieves the desired element for a given seconds
	 * it throws assertion error not if the element does not exist
	 * it is generally used to retrieve the elements which are generated by JS
	 * @param locator
	 * @return WebElement
	 */
	public static WebElement waitForElementVisibleWithAssert(SeleniumWaiter sw, String locator, int waitTime) {
		WebElement webElement;
		
		if (BuildConfig.headless) {
			Tools.forceToWait(8);
			webElement = sw.waitForElement(locator, ElementType.CSSSELECTOR, waitTime);
			Assert.assertNotNull(webElement);
		} else {
			do {
				Tools.forceToWaitInMilli(100);
				webElement = sw.waitForElement(locator, ElementType.CSSSELECTOR, waitTime);
				Assert.assertNotNull(webElement);
			} while (!webElement.isDisplayed());
		}
		
		return webElement;
	}
	
}
